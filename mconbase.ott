metavar value_name, x ::=
  {{ isa string }} {{ coq nat }} {{ coq-equality }} {{ hol string }} {{ ocaml int }}
  {{ lex alphanum }} 
metavar label, lab ::=
  {{ isa string }} {{ coq nat }} {{ coq-equality }} {{ hol string }} {{ ocaml int }}
  {{ lex alphanum }} 
metavar ident ::=
  {{ isa string }} {{ coq nat }} {{ hol string }} {{ ocaml int }}
  {{ lex Alphanum }} 
indexvar index, i, j, n, m ::=
  {{ isa nat }} {{ coq nat }}  {{ hol num }} {{ ocaml int }}
  {{ lex numeral }}
% the lex specifications above are not accurate - negative numerals, especially, 
% should be supported

grammar
% Type variables
typvar, tv :: TV_ ::= {{ coq-equality decide equality. apply eq_value_name. }}
  | ' ident                            ::   :: ident


% Type constants
typconst, tc :: TC_ ::=
  | tunit                               ::   :: unit

% Type terms
typexpr, t :: TE_ ::=
  | typconst                           ::   :: constants
  | typvar                             ::   :: var
  | typexpr -> typexpr'                ::   :: arrow
  | typexpr '*' typexpr'               ::   :: prod
  | con typexpr                        ::   :: concurrent
  | typexpr '+' typexpr'               ::   :: sum
  | ( typexpr )                        :: S :: paren {{ ich [[typexpr]] }} {{ ocaml [[typexpr]] }}

% Constants
constant, c :: CONST_ ::=
  | ret                                ::   :: ret
  | fork                               ::   :: fork
  | unit                                 ::   :: unit
  | stop                                 ::   :: stop
  | pair                                 ::   :: pair
  | proj1                                ::   :: proj1
  | proj2                                ::   :: proj2

redlabel, rl :: RL_ ::=
  | tau                                    ::   :: tau
  | lab                                ::   :: labelled

% Live modes
livemodes, lm :: LM_ ::=
  | comp lab                               ::    :: comp
  | exp expr                           ::    :: expr
  | ( lm )                             :: S :: paren {{ ich [[lm]] }} {{ ocaml [[lm]] }}

% Terms
expr, e :: E_ ::=
  | value_name                           ::   :: ident
  | constant                             ::   :: constant
%  |  {{ coq (E_apply (E_constant CONST_fork) [[expr]]) }}
%  | fork expr                            :: S ::  fork_curry  {{ coq (E_apply (E_constant CONST_fork) [[expr]]) }}
  | expr expr'                           ::   :: apply 
  | expr >>= expr'                       ::   :: bind
  | function value_name : typexpr -> expr          ::   :: function (+ bind value_name in expr +)
  | fix e                                ::   :: fix
  | live lm                            ::   :: live_expr
  | { e , e' }                           ::   :: pair
  | ( expr )                             :: S :: paren {{ ich [[expr]] }} {{ ocaml [[expr]] }}
  | inl e                                ::   :: taggingleft
  | inr e                                ::   :: taggingright
  | case e1 of inl x1  => e2 | inr x2 => e3  ::   :: case
  | { v / x } e                        :: M :: subst 
    {{ isa subst_expr [[v]] [[x]] [[e]] }}
    {{ ch (subst_expr [[v]] [[x]] [[e]]) }}
    {{ ocaml (subst_expr [[v]] [[x]] [[e]]) }}
  | { ( fix (function x : t -> e) ) / x' } e                      :: M :: fix_subst 
    {{ isa subst_expr (E_fix  (E_function [[x]] [[t]] [[e]]) ) [[x']] [[e]] }}
    {{ ch (subst_expr (E_fix  (E_function [[x]] [[t]] [[e]]) ) [[x']] [[e]]) }}
    {{ ocaml (subst_expr (E_fix  (E_function [[x]] [[t]] [[e]]) ) [[x']] [[e]]) }}



%Values
value, v :: V_ ::=
  | constant                           ::   :: constant
  | function value_name : typexpr -> expr        ::   :: function
  | live lm                         ::   :: live_expr
  | inl v                              ::   :: taggedleft
  | inr v                              ::   :: taggedright
  | { v , v' }                         ::   :: valuepair
  | ( v )                             :: S :: paren {{ ich [[v]] }} {{ ocaml [[v]] }}

%Selects
select, s :: S_ ::=
  | First                              ::   :: First {{ tex 1 }}
  | Second                             ::   :: Second {{ tex 2 }}

%Type environment
G {{ tex \Gamma }} :: G_ ::=
  | empty                              ::   :: em
  | G , value_name : typexpr         ::   :: vn

formula :: formula_ ::=
  | judgement                          ::   :: judgement
  | not ( formula )                    ::   :: not  
        {{ isa Not([[formula]]) }}
        {{ coq not([[formula]]) }}
        {{ hol ~([[formula]]) }}
        {{ ocaml TODO }}
  | value_name = value_name'           ::   :: eqv 
        {{ ich [[value_name]]=[[value_name']] }} {{ ocaml TODO }}


%Terminals
terminals :: terminals_ ::=
  |  ->                                ::   :: arrow      {{ tex \rightarrow }}
  |  function                          ::   :: function   {{ tex \lambda }}
  | |-                                 ::   :: turnstile  {{ tex \vdash }}
  | -->                                ::   :: red        {{ tex \longrightarrow }}
  | '{'                                ::   :: leftbrace  {{ tex \{ }}
  | '}'                                ::   :: rightbrace {{ tex \} }}
  | '['                                ::   :: leftsqbrack  {{ tex [ }}
  | ']'                                ::   :: rightsqbrack {{ tex ] }}
  | con                                ::   :: concurrent {{ tex \textbf{con} }}
  | comp                               ::   :: computation {{ tex comp }}
  | exp                                ::   :: expression {{ tex exp }}
  | live                               ::   :: conlive    {{ tex Live }}
  | fix                                ::   :: fix        {{ tex \textbf{fix} }}
  | tau                                ::   :: tau        {{ tex \tau }}
  | >>=                                ::   :: bind {{ tex >>= }}
  | '*'                                ::   :: product_t    {{ tex * }}
  | ','                                ::   :: pair_elem   {{ tex , }}
  | inl                                ::   :: lefttag     {{ tex \textbf{left} }}
  | inr                                ::   :: righttag    {{ tex \textbf{right} }}
  | case                               ::   :: case    {{ tex Case }}
  | of                                 ::   :: of       {{ tex of }}
  | =>                                 ::   :: doublearrow {{ tex \Rightarrow }}
  | '+'                                ::   :: plus {{ tex + }}
  | ':'                                ::   :: funtype {{ tex : }}

%parsing 
%V_fork_curry <= V_constant
  
% Subsumption: values are expressions
subrules
  v <:: expr

substitutions
  single   expr value_name :: subst  
  multiple typexpr typvar  :: tsubst 

freevars
  typexpr typvar :: ftv
  expr value_name :: fv

embed

  {{ hol
val _ = Define `
  (remove_duplicates [] = []) /\
  (remove_duplicates (x::xs) = if (MEM x xs) then remove_duplicates xs 
                               else x::(remove_duplicates xs))
`; }}


defns 
Jtype :: '' ::= 

defn 
value_name : typexpr in G  :: :: VTSin :: VTSin_ by

--------------------------------------------------- :: vn1
value_name : typexpr in G, value_name:typexpr

value_name : typexpr in G
not(value_name = value_name')
--------------------------------------------------- :: vn2
value_name : typexpr in G, value_name':typexpr'


% base typing rules
defn
G |- constant : t :: :: G_constant :: constant_ by

% Primitive functions

------------------------ :: ret
G |- ret : t -> con t

------------------------ :: fork
G |- fork : (con t1) -> ((con t2) -> (con ((t1 * (con t2)) + ((con t1) * t2))))


------------------------ :: unit
G |- unit : tunit


------------------------ :: stop
G |- stop : t

----------------------------------------:: pair
G |- pair : t1 -> ( t2 -> ( t1 * t2 ) )

-------------------------------:: proj1
G |- proj1 : ( t1 * t2 ) -> t1

-------------------------------:: proj2
G |- proj2 : ( t1 * t2 ) -> t2



% typing rules
defn 
G |- e : t :: :: Get :: Get_ by

x:t in G   
---------------- :: value_name
G |- x:t

:G_constant: G |- constant : t
------------------------------ :: constant
G |- constant : t

G |- e : t1->t2
G |- e' : t1 
---------------- :: apply
G |- e e' : t2

G,x1: t1 |- e : t
--------------------------- I :: lambda
G |- function x1 : t1 -> e : t1->t

G |- e : t
---------------------------  :: live_exp
G |- live exp e : con t

---------------------------  :: live_comp
G |- live ( comp lab ) : con tunit

G |- e :  t -> t 
------------------------ :: fix
G |- fix e : t

G |- e : con t
G |- e' : t -> con t'
----------------------- :: bind
G |- e >>= e' : con t'

G |- e : t1
G |- e' : t2 
---------------- :: pair
G |- :E_pair: {e,e'} : (t1*t2)


% Sum type things
     G |- e : t
--------------------------- :: TInl
G |- inl e : t + t' 

     G |- e : t
--------------------------- :: TInr
G |- inr e : t' + t 

G |- e : t + t'
G,x : t |- e' : t''
G,x' : t' |- e'' : t''
--------------------------- :: TCase
G |- case e of inl x => e' | inr x' => e'' : t''

%evaluation rules
defns 
Jop :: JO_ ::= 

defn 
e [ s ] --> [ rl ]  e' :: :: red :: red_ {{ tex [[e]]\, \overset{ [[rl]] }{\underset{ [[s]] }{\longrightarrow} }\, [[e']] }} by 

------------------------------- :: app
(function x : t -> e)  v [ s ] --> [ tau ] {v/x}  e

%Concurrent constructs

%Live exressions are not allowed to move directly

%e --> e'
%--------------------------- :: live
%live e -->  live e'

%and finish

%--------------------------- :: die
%live v --> dead v

%Here should be the only path for concurrency

e [ s ] --> [ rl ] e''
--------------------------- :: forkmove1
(:E_apply:fork (live exp e) ) (live lm) [ First ] --> [ rl ] (:E_apply:fork (live exp e'') ) (live lm)


e' [ s ] --> [ rl ] e''
--------------------------- :: forkmove2
(:E_apply:fork (live lm) ) (live exp e') [ Second ] --> [ rl ] (:E_apply:fork (live lm) ) (live exp e'') 

--------------------------- :: forkdeath1
(:E_apply:fork (live exp v) ) (live lm) [ First ] --> [ tau ] live exp ( inl ( ( { v , ( live lm ) } ) ) )

--------------------------- :: forkdeath2
(:E_apply:fork (live lm) ) (live exp v') [ Second ] --> [ tau ] live exp ( inr ( { (live lm) , v' } ) )

% Now for the evaluation steps that have to modified to incorporate the actual OCaml code

--------------------------- :: forkdocomp1
(:E_apply:fork (live ( comp lab ) ) ) (live lm) [ First ] --> [ lab ] live exp ( inl ( ( { unit , (live lm) } ) ) )

--------------------------- :: forkdocomp2
(:E_apply:fork (live lm) ) (live ( comp lab )) [ Second ] --> [ lab ]  live exp ( inr ( ( { (live lm) , unit } ) ))





--------------------------- :: ret
ret v [ s ] --> [ tau ] ( live exp v ) 

e [ s ] --> [ rl ] e'
--------------------------- :: evalbind
e >>= e'' [ s ] --> [ rl ] e' >>= e''

e [ s ] --> [ rl ] e'
--------------------------- :: movebind
(live exp e) >>= e'' [ s ] --> [ rl ] (live exp e') >>= e'' 

--------------------------- :: compbind
(live (comp lab) ) >>= e [ s ] --> [ lab ] e unit

--------------------------- :: dobind
(live exp v) >>= e [ s ] --> [ tau ] e v 

%Context-application
% Evaluate argument first
% then the function
% the rest is taken care of by the app

e' [ s ] --> [ rl ] e''
--------------  :: context_app2
v e' [ s ] --> [ rl ] v e''

e [ s ] --> [ rl ] e''
------------  :: context_app1
e e' [ s ] --> [ rl ] e'' e'


%Fixpoint operator
% This heavily relies on well typed-ness 

e [ s ] --> [ rl ] e'
------------------------------  :: fix_move
( fix e ) [ s ] --> [ rl ] ( fix e' )

----------------------- :: fix_app
( fix (function x : t -> e) )  [ s ] --> [ tau ] { ( fix (function x : t -> e) ) / x } e

% Pairs
% Note this could be defined to be parallel, but I want to constrain concurrency to fork
e [ s ] --> [ rl ] e' 
----------------------- :: pair_1
{ e , e'' } [ s ] --> [ rl ] { e' , e'' }

e [ s ] --> [ rl ] e'
----------------------- :: pair_2
{ v , e } [ s ] --> [ rl ] { v, e' }


------------------------------------------ :: inpair
( pair v ) v' [ s ] --> [ tau ] { v , v' }

-------------------------------------------:: proj1
proj1 { v , v' } [ s ] --> [ tau ] v

-------------------------------------------:: proj2
proj2 { v , v' } [ s ] --> [ tau ] v'


%Sum types
    e [ s ] --> [ rl ] e'
-------------------------- :: evalinl
inl e [ s ] --> [ rl ] inl e'

    e [ s ] --> [ rl ] e'
-------------------------- :: evalinr
inr e [ s ] --> [ rl ] inr e'

--------------------------------------------------------- :: evalcaseinl
case (inl v) of inl x => e | inr x' => e' [ s ] --> [ tau ] { v / x } e

--------------------------------------------------------- :: evalcaseinr
case (inr v) of inl x => e | inr x' => e' [ s ] --> [ tau ] { v / x' } e'

                                      e [ s ] --> [ rl ] e'
------------------------------------------------------------------------------------ :: evalcase
case e of inl x => e'' | inr x' => e''' [ s ] --> [ rl ] case e' of inl x => e'' | inr x' => e'''
