metavar value_name, x ::=
  {{ isa string }} {{ coq nat }} {{ coq-equality }} {{ hol string }} {{ ocaml int }}
  {{ lex alphanum }} 
metavar ident ::=
  {{ isa string }} {{ coq nat }} {{ hol string }} {{ ocaml int }}
  {{ lex Alphanum }} 
indexvar index, i, j, n, m ::=
  {{ isa nat }} {{ coq nat }}  {{ hol num }} {{ ocaml int }}
  {{ lex numeral }}
% the lex specifications above are not accurate - negative numerals, especially, 
% should be supported

grammar
% Type variables
typvar, tv :: TV_ ::= {{ coq-equality decide equality. apply eq_value_name. }}
  | ' ident                            ::   :: ident


% Type constants
typconst, tc :: TC_ ::=
  | tunit                               ::   :: unit

% Type terms
typexpr, t :: TE_ ::=
  | typconst                           ::   :: constants
  | typvar                             ::   :: var
  | typexpr -> typexpr'                ::   :: arrow
  | typexpr '*' typexpr'               ::   :: prod
  | con typexpr                        ::   :: concurrent
  | typexpr '+' typexpr'               ::   :: sum
  | ( typexpr )                        :: S :: paren {{ ich [[typexpr]] }} {{ ocaml [[typexpr]] }}

% Type scheme
typscheme, ts :: TS_ ::=  
  | ( typvar1 , .. , typvarn ) typexpr ::   :: ts  (+ bind typvar1 .. typvarn in typexpr +) 

  | generalise ( G , t )               :: M :: ts3 
    {{ isa (TS_ts (List.remdups (list_minus (ftv_typexpr [[t]]) (ftv_G [[G]]))) [[t]]) }}
    {{ coq (TS_ts (remove_duplicates (make_list_typvar (list_minus eq_typvar (ftv_typexpr [[t]]) (ftv_G [[G]])))) [[t]]) }} 
    {{ hol (TS_ts (remove_duplicates (list_minus (ftv_typexpr [[t]]) (ftv_G [[G]]))) [[t]]) }}
    {{ ocaml TODO }}

%TODO: it might be nicer to have ftv remove duplicates, or indeed
%return a set

% Constants
constant, c :: CONST_ ::=
  | ret                                ::   :: ret
  | fork                               ::   :: fork
  | unit                                 ::   :: unit
  | stop                                 ::   :: stop

% Live modes
livemodes, lm :: LM_ ::=
  | comp                               ::    :: comp
  | exp expr                           ::    :: expr

% Terms
expr, e :: E_ ::=
  | value_name                           ::   :: ident
  | constant                             ::   :: constant
%  |  {{ coq (E_apply (E_constant CONST_fork) [[expr]]) }}
%  | fork expr                            :: S ::  fork_curry  {{ coq (E_apply (E_constant CONST_fork) [[expr]]) }}
  | expr expr'                           ::   :: apply 
  | expr >>= expr'                       ::   :: bind
  | function value_name : typexpr -> expr          ::   :: function (+ bind value_name in expr +)
  | fix e                                ::   :: fix
  | live lm                            ::   :: live_expr
  | { e , e' }                           ::   :: pair
  | ( expr )                             :: S :: paren {{ ich [[expr]] }} {{ ocaml [[expr]] }}
  | inl e                                ::   :: taggingleft
  | inr e                                ::   :: taggingright
  | case e1 of inl x1  => e2 | inr x2 => e3  ::   :: case
  | { v / x } e                        :: M :: subst 
    {{ isa subst_expr [[v]] [[x]] [[e]] }}
    {{ ch (subst_expr [[v]] [[x]] [[e]]) }}
    {{ ocaml (subst_expr [[v]] [[x]] [[e]]) }}


%Values
value, v :: V_ ::=
  | constant                           ::   :: constant
  | function value_name : typexpr -> expr        ::   :: function
  | live lm                         ::   :: live_expr
  | inl v                              ::   :: taggedleft
  | inr v                              ::   :: taggedright
  | fix v                              ::   :: fix
  | { v , v' }                         ::   :: valuepair
  | ( v )                             :: S :: paren {{ ich [[v]] }} {{ ocaml [[v]] }}

%Selects
select, s :: S_ ::=
  | First                              ::   :: First
  | Second                             ::   :: Second

%Type environment
G {{ tex \Gamma }} :: G_ ::=
  | empty                              ::   :: em
  | G , value_name : typscheme         ::   :: vn

formula :: formula_ ::=
  | judgement                          ::   :: judgement
  | not ( formula )                    ::   :: not  
        {{ isa Not([[formula]]) }}
        {{ coq not([[formula]]) }}
        {{ hol ~([[formula]]) }}
        {{ ocaml TODO }}

  | typscheme > t                      ::   :: gen 
        {{ isa ? typvars . ? typexpr . ? s . 
             [[typscheme]] = TS_ts typvars typexpr 
             & typvars=List.map fst s 
             & tsubst_typexpr s typexpr = [[t]] }}
        {{ coq (exists tvs, exists txp, exists s, 
             [[typscheme]] = TS_ts tvs txp 
             /\ tvs = make_list_typvar
                    (List.map (fun (x:typvar*typexpr) => match x with (x1,x2) => x1 end) 
                              s)  
             /\ tsubst_typexpr s txp = [[t]]) }}
        {{ hol ? typvars typexpr s . 
             ([[typscheme]] = TS_ts typvars typexpr )
             /\ (typvars=MAP FST s )
             /\ (tsubst_typexpr s typexpr = [[t]]) }}
        {{ ocaml TODO }}

  | typscheme = typscheme'             ::   :: eqt 
        {{ ich [[typscheme]]=[[typscheme']] }} {{ ocaml TODO }}
  | value_name = value_name'           ::   :: eqv 
        {{ ich [[value_name]]=[[value_name']] }} {{ ocaml TODO }}


%Terminals
terminals :: terminals_ ::=
  |  ->                                ::   :: arrow      {{ tex \rightarrow }}
  |  function                          ::   :: function   {{ tex \textbf{function} }}
  | |-                                 ::   :: turnstile  {{ tex \vdash }}
  | -->                                ::   :: red        {{ tex \longrightarrow }}
  | '{'                                ::   :: leftbrace  {{ tex \{ }}
  | '}'                                ::   :: rightbrace {{ tex \} }}
  | '['                                ::   :: leftsqbrack  {{ tex [ }}
  | ']'                                ::   :: rightsqbrack {{ tex ] }}
  | con                                ::   :: concurrent {{ tex \textbf{concurrent} }}
  | comp                               ::   :: computation {{ tex comp }}
  | exp                                ::   :: expression {{ tex exp }}
  | live                               ::   :: conlive    {{ tex Live }}
  | fix                                ::   :: fix        {{ tex \textbf{fix} }}
  | >>=                                ::   :: bind {{ tex >>= }}
  | '*'                                ::   :: product_t    {{ tex * }}
  | ','                                ::   :: pair_elem   {{ tex , }}
  | inl                                ::   :: lefttag     {{ tex Left tag }}
  | inr                                ::   :: righttag    {{ tex Right tag }}
  | case                               ::   :: case    {{ tex Case }}
  | of                                 ::   :: of       {{ tex of }}
  | =>                                 ::   :: doublearrow {{ tex \Rightarrow }}
  | '+'                                ::   :: plus {{ tex + }}
  | ':'                                ::   :: funtype {{ tex : }}

%parsing 
%V_fork_curry <= V_constant
  
% Subsumption: values are expressions
subrules
  v <:: expr

substitutions
  single   expr value_name :: subst  
  multiple typexpr typvar  :: tsubst 

freevars
  typexpr typvar :: ftv

embed
  {{ coq
Fixpoint remove_duplicates (l:list_typvar) : list_typvar :=
  match l with
  | Nil_list_typvar => Nil_list_typvar
  | Cons_list_typvar h t => 
    if (list_mem eq_typvar h (unmake_list_typvar t))  
    then remove_duplicates t
    else Cons_list_typvar h (remove_duplicates t)
end. }}

  {{ hol
val _ = Define `
  (remove_duplicates [] = []) /\
  (remove_duplicates (x::xs) = if (MEM x xs) then remove_duplicates xs 
                               else x::(remove_duplicates xs))
`; }}


defns 
Jtype :: '' ::= 

defn 
value_name : typscheme in G  :: :: VTSin :: VTSin_ by

--------------------------------------------------- :: vn1
value_name : typscheme in G, value_name:typscheme

value_name : typscheme in G
not(value_name = value_name')
--------------------------------------------------- :: vn2
value_name : typscheme in G, value_name':typscheme'


% base typing rules
defn
G |- constant : t :: :: G_constant :: constant_ by

% Primitive functions

------------------------ :: ret
G |- ret : t -> con t

------------------------ :: fork
G |- fork : (con t1) -> ((con t2) -> (con (((t1*t2) + (t1 * (con t2))) + ((con t1) * t2))))


------------------------ :: unit
G |- unit : tunit


------------------------ :: stop
G |- stop : t



% typing rules
defn 
G |- e : t :: :: Get :: Get_ by

x:typscheme in G
typscheme > t   
---------------- :: value_name
G |- x:t

:G_constant: G |- constant : t
------------------------------ :: constant
G |- constant : t

G |- e : t1->t2
G |- e' : t1 
---------------- :: apply
G |- e e' : t2

G,x1: ( ) t1 |- e : t
--------------------------- I :: lambda
G |- function x1 : t1 -> e : t1->t

G |- e : t
---------------------------  :: live_exp
G |- live exp e : con t

---------------------------  :: live_comp
G |- live comp : con tunit

G |- e : t -> t
------------------------ :: fix
G |- fix e : t

G |- e : con t
G |- e' : t -> con t'
----------------------- :: bind
G |- e >>= e' : con t'

G |- e : t1
G |- e' : t2 
---------------- :: pair
G |- :E_pair: {e,e'} : (t1*t2)


% Sum type things
     G |- e : t
--------------------------- :: TInl
G |- inl e : t + t' 

     G |- e : t
--------------------------- :: TInr
G |- inr e : t' + t 

G |- e : t + t'
G,x : ( ) t |- e' : t''
G,x' : ( ) t' |- e'' : t''
--------------------------- :: TCase
G |- case e of inl x => e' | inr x' => e'' : t''

%evaluation rules
defns 
Jop :: JO_ ::= 

defn 
e [ s ] --> e' :: :: red :: red_ by

------------------------------- :: app
(function x : t -> e)  v [ s ] --> {v/x}  e

%Concurrent constructs

%Live exressions are not allowed to move directly

%e --> e'
%--------------------------- :: live
%live e -->  live e'

%and finish

%--------------------------- :: die
%live v --> dead v

%Here should be the only path for concurrency

{{ ~ ( is_value_of_expr ( [[e']] ) ) }}
e [ s ] --> e''
--------------------------- :: forkmove1
(:E_apply:fork (live exp e) ) (live exp e') [ First ] -->  (:E_apply:fork (live exp e'') ) (live exp e')

{{ ~ ( is_value_of_expr ( [[e]] ) ) }}
e' [ s ] --> e''
--------------------------- :: forkmove2
(:E_apply:fork (live exp e) ) (live exp e') [ Second ] -->  (:E_apply:fork (live exp e) ) (live exp e'') 

--------------------------- :: forkdeath1
(:E_apply:fork (live exp v) ) (live exp e) [ s ] -->  live exp ( inl ( inr ( { v , ( live exp e ) } ) ) )

--------------------------- :: forkdeath2
(:E_apply:fork (live exp e) ) (live exp v') [ s ] -->  live exp ( inr ( { (live exp e) , v' } ) )

--------------------------- :: forkdeath12
(:E_apply:fork (live exp v) ) (live exp v') [ s ] -->  live exp ( inl ( inl ( { v , v' } ) ) )

% Now for the evaluation steps that have to modified to incorporate the actual OCaml code

--------------------------- :: forkdocomp1
(:E_apply:fork (live comp) ) (live exp e) [ s ] -->  live exp ( inl ( inr ( { unit , (live exp e) } ) ) )

--------------------------- :: forkdocomp2
(:E_apply:fork (live exp e) ) (live comp) [ s ] -->  live exp ( inr ( { (live exp e) , unit } ) )

--------------------------- :: forkdocomp12
(:E_apply:fork (live comp) ) (live comp) [ s ] -->  live exp ( inl ( inl ( { unit , unit } ) ) )




--------------------------- :: ret
ret v [ s ] --> ( live exp v ) 

e [ s ] --> e'
--------------------------- :: evalbind
e >>= e'' [ s ] --> e' >>= e''

e [ s ] --> e'
--------------------------- :: movebind
(live exp e) >>= e'' [ s ] --> (live exp e') >>= e'' 

--------------------------- :: compbind
(live comp) >>= e [ s ] --> e' unit

--------------------------- :: dobind
(live exp v) >>= e [ s ] --> e v 

%Context-application
% Evaluate argument first
% then the function
% the rest is taken care of by the app

e' [ s ] --> e''
--------------  :: context_app1
e e' [ s ] --> e e''

e [ s ] --> e'
------------  :: context_app2
e v [ s ] --> e' v


%Fixpoint operator
% This heavily relies on well typed-ness 

e [ s ] --> e'
------------------------------  :: fix_move
( fix e ) [ s ] --> ( fix e' )

----------------------- :: fix_app
( fix v ) v' [ s ] --> ( fix v ) ( v v' )

% Pairs
% Note this could be defined to be parallel, but I want to constrain concurrency to fork
e [ s ] --> e' 
----------------------- :: pair_1
{ e , e'' } [ s ] --> { e' , e'' }

e [ s ] --> e'
----------------------- :: pair_2
{ v , e } [ s ] --> { v, e' }


%Sum types
    e [ s ] --> e'
---------------- :: evalinl
inl e [ s ] --> inl e'

    e [ s ] --> e'
---------------- :: evalinr
inr e [ s ] --> inr e'

--------------------------------------------------------- :: evalcaseinl
case (inl v) of inl x => e | inr x' => e' [ s ] --> { v / x } e

--------------------------------------------------------- :: evalcaseinr
case (inr v) of inl x => e | inr x' => e' [ s ] --> { v / x' } e'

                                      e [ s ] --> e'
------------------------------------------------------------------------------------ :: evalcase
case e of inl x => e'' | inr x' => e''' [ s ] --> case e' of inl x => e'' | inr x' => e'''
