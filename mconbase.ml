(* generated by Ott 0.23 from: mconbase.ott *)

type value_name = int
type ident = int
type index = int

type 
typvar = 
   TV_ident of ident


type 
typexpr = 
   TE_var of typvar
 | TE_arrow of typexpr * typexpr
 | TE_prod of typexpr * typexpr
 | TE_concurrent of typexpr
 | TE_sum of typexpr * typexpr


type 
constant = 
   CONST_ret
 | CONST_fork


type 
typscheme = 
   TS_ts of (typvar) list * typexpr


type 
expr = 
   E_ident of value_name
 | E_constant of constant
 | E_apply of expr * expr
 | E_bind of expr * expr
 | E_function of value_name * expr
 | E_live_expr of expr
 | E_dead_expr of expr
 | E_pair of expr * expr
 | E_taggingleft of expr
 | E_taggingright of expr
 | E_case of expr * value_name * expr * value_name * expr


type 
g = 
   G_em
 | G_vn of g * value_name * typscheme


(** subrules *)
let rec is_expr_of_expr (e_5:expr) : bool =
  match e_5 with
  | (E_ident value_name) -> (true)
  | (E_constant constant) -> (true)
  | (E_apply (expr,expr')) -> ((is_expr_of_expr expr) && (is_expr_of_expr expr'))
  | (E_bind (expr,expr')) -> ((is_expr_of_expr expr) && (is_expr_of_expr expr'))
  | (E_function (value_name,expr)) -> ((is_expr_of_expr expr))
  | (E_live_expr expr) -> ((is_expr_of_expr expr))
  | (E_dead_expr value) -> ((is_value_of_expr value))
  | (E_pair (e,e')) -> ((is_expr_of_expr e) && (is_expr_of_expr e'))
  | (E_taggingleft e) -> ((is_expr_of_expr e))
  | (E_taggingright e) -> ((is_expr_of_expr e))
  | (E_case (e1,x1,e2,x2,e3)) -> ((is_expr_of_expr e1) && (is_expr_of_expr e2) && (is_expr_of_expr e3))
and
is_value_of_expr (e_5:expr) : bool =
  match e_5 with
  | (E_ident value_name) -> false
  | (E_constant constant) -> (true)
  | (E_apply (expr,expr')) -> false
  | (E_bind (expr,expr')) -> false
  | (E_function (value_name,expr)) -> ((is_expr_of_expr expr))
  | (E_live_expr expr) -> ((is_expr_of_expr expr))
  | (E_dead_expr value) -> false
  | (E_pair (e,e')) -> ((is_value_of_expr e) && (is_value_of_expr e'))
  | (E_taggingleft e) -> ((is_value_of_expr e))
  | (E_taggingright e) -> ((is_value_of_expr e))
  | (E_case (e1,x1,e2,x2,e3)) -> false



(** substitutions *)
let rec tsubst_typexpr (sub: (typvar*typexpr) list) (t_6:typexpr) : typexpr =
  match t_6 with
  | (TE_var typvar) -> (try List.assoc typvar sub with Not_found -> (TE_var typvar))
  | (TE_arrow (typexpr,typexpr')) -> TE_arrow ((tsubst_typexpr sub typexpr),(tsubst_typexpr sub typexpr'))
  | (TE_prod (typexpr,typexpr')) -> TE_prod ((tsubst_typexpr sub typexpr),(tsubst_typexpr sub typexpr'))
  | (TE_concurrent typexpr) -> TE_concurrent (tsubst_typexpr sub typexpr)
  | (TE_sum (typexpr,typexpr')) -> TE_sum ((tsubst_typexpr sub typexpr),(tsubst_typexpr sub typexpr'))


let tsubst_typscheme (sub: (typvar*typexpr) list) (ts5:typscheme) : typscheme =
  match ts5 with
  | (TS_ts ((typvar_list),typexpr)) -> TS_ts (typvar_list,(tsubst_typexpr (List.filter (fun (tv5,t5) -> not(List.mem tv5 (typvar_list))) sub) typexpr))


let rec subst_expr (e_5:expr) (x_5:value_name) (e__6:expr) : expr =
  match e__6 with
  | (E_ident value_name) -> (if value_name=x_5 then e_5 else (E_ident value_name))
  | (E_constant constant) -> E_constant constant
  | (E_apply (expr,expr')) -> E_apply ((subst_expr e_5 x_5 expr),(subst_expr e_5 x_5 expr'))
  | (E_bind (expr,expr')) -> E_bind ((subst_expr e_5 x_5 expr),(subst_expr e_5 x_5 expr'))
  | (E_function (value_name,expr)) -> E_function (value_name,(if List.mem x_5 ([value_name]) then expr else (subst_expr e_5 x_5 expr)))
  | (E_live_expr expr) -> E_live_expr (subst_expr e_5 x_5 expr)
  | (E_dead_expr value) -> E_dead_expr value
  | (E_pair (e,e')) -> E_pair ((subst_expr e_5 x_5 e),(subst_expr e_5 x_5 e'))
  | (E_taggingleft e) -> E_taggingleft (subst_expr e_5 x_5 e)
  | (E_taggingright e) -> E_taggingright (subst_expr e_5 x_5 e)
  | (E_case (e1,x1,e2,x2,e3)) -> E_case ((subst_expr e_5 x_5 e1),x1,(subst_expr e_5 x_5 e2),x2,(subst_expr e_5 x_5 e3))


let rec tsubst_g (sub: (typvar*typexpr) list) (g5:g) : g =
  match g5 with
  | G_em -> G_em 
  | (G_vn (g,value_name,typscheme)) -> G_vn ((tsubst_g sub g),value_name,(tsubst_typscheme sub typscheme))


(** library functions *)
let rec list_minus (l1:'a list) (l2:'a list) : 'a list =
  match l1 with
  | [] -> []
  | h::t -> if (List.mem h l2) then list_minus t l2 else h::(list_minus t l2)


(** free variables *)
let rec ftv_typexpr (t5:typexpr) : typvar list =
  match t5 with
  | (TE_var typvar) -> [typvar]
  | (TE_arrow (typexpr,typexpr')) -> (ftv_typexpr typexpr) @ (ftv_typexpr typexpr')
  | (TE_prod (typexpr,typexpr')) -> (ftv_typexpr typexpr) @ (ftv_typexpr typexpr')
  | (TE_concurrent typexpr) -> (ftv_typexpr typexpr)
  | (TE_sum (typexpr,typexpr')) -> (ftv_typexpr typexpr) @ (ftv_typexpr typexpr')


let ftv_typscheme (ts5:typscheme) : typvar list =
  match ts5 with
  | (TS_ts ((typvar_list),typexpr)) -> [] @ (list_minus (ftv_typexpr typexpr) typvar_list)


let rec ftv_g (g5:g) : typvar list =
  match g5 with
  | G_em -> []
  | (G_vn (g,value_name,typscheme)) -> (ftv_g g) @ (ftv_typscheme typscheme)


(** definitions *)
(** definitions *)


