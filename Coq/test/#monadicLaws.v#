(* Inductive option (A : Type) :=
 | Some : A -> option A
 | None : option A.

Implicit Arguments Some [A].
Implicit Arguments None [A].

Definition ret {A : Type} (x : A) := Some x.

Definition bind {A B : Type} (a : option A) (f : A -> option B) : option B :=
 match a with 
  | Some x => f x
  | None => None
 end.

Notation "A >>= F" := (bind A F) (at level 42, left associativity).


Lemma mon_left_id : forall (A B: Type) (a : A) (f : A -> option B),
  ret a >>= f = f a.
intros.
reflexivity.
Qed.

Lemma mon_right_id : forall (A : Type) (a : option A),
    a >>= ret = a.
intros.
induction a; repeat reflexivity.
Qed.

Lemma mon_assoc :
  forall (A B C : Type) (a : option A) (f : A -> option B) (g : B -> option C),
    (a >>= f) >>= g = a >>= (fun x => f x >>= g).
intros.
induction a; repeat reflexivity.
Qed. *)

Inductive concurrent (A : Type) :=
  | Live : A -> concurrent A
  | Dead : concurrent A.

Implicit Arguments Live [A].
Implicit Arguments Dead [A].

Definition ret {A : Type} (x : A) := Live x.

Definition bind {A B : Type} (a : concurrent A) (f : A -> concurrent B) : concurrent B :=
 match a with 
  | Live x => f x
  | Dead => Dead
 end.

Notation "A >>= F" := (bind A F) (at level 42, left associativity).

Definition seq {A B: Type} (a : concurrent A) (b : concurrent B) : concurrent B := a >>= (fun y => b). 

(* Definition fork {A B: Type} (a : concurrent A) (b : concurrent B) : concurrent (A B) :=
  match a with
   | Dead => Dead
   | Live x => match b with *)

Lemma mon_left_id : forall (A B: Type) (a : A) (f : A -> concurrent B),
  ret a >>= f = f a.
intros.
reflexivity.
Qed.

Lemma mon_right_id : forall (A : Type) (a : concurrent A),
    a >>= ret = a.
intros.
induction a; repeat reflexivity.
Qed.

Lemma mon_assoc :
  forall (A B C : Type) (a : concurrent A) (f : A -> concurrent B) (g : B -> concurrent C),
    (a >>= f) >>= g = a >>= (fun x => f x >>= g).
intros.
induction a; repeat reflexivity.
Qed.

