(****************************************************************************)
(*  RelationExtraction - Extraction of inductive relations for Coq          *)
(*                                                                          *)
(*  This program is free software: you can redistribute it and/or modify    *)
(*  it under the terms of the GNU General Public License as published by    *)
(*  the Free Software Foundation, either version 3 of the License, or       *)
(*  (at your option) any later version.                                     *)
(*                                                                          *)
(*  This program is distributed in the hope that it will be useful,         *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of          *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *)
(*  GNU General Public License for more details.                            *)
(*                                                                          *)
(*  You should have received a copy of the GNU General Public License       *)
(*  along with this program.  If not, see <http://www.gnu.org/licenses/>.   *)
(*                                                                          *)
(*  Copyright 2012 CNAM-ENSIIE                                              *)
(*                 Catherine Dubois <dubois@ensiie.fr>                      *)
(*                 David Delahaye <david.delahaye@cnam.fr>                  *)
(*                 Pierre-Nicolas Tollitte <tollitte@ensiie.fr>             *)
(****************************************************************************)

(*****************)
(* Proof schemes *)
(*****************)

(* An identivier (for variables), with the variable name in the fix function
   and eventually in the specification. *)
type pident = {
  pi_func_name : string;
  pi_spec_name : string option;
}

(* Information used to link atoms with the specification premisses. *)
type prem_orig = {
  po_prem_name : string;
  (* We can add more information here if needed.
     ex: precise places of each construction in the original specification *)
}

(* An atomic proof tip. 't is the type of a term. *)
type 't ps_atom =
  | LetVar of (pident * 't * prem_orig)
    (* let pident := 't in *)
  | CaseConstr of ('t * string * pident list * prem_orig)
    (* match 't with | string (pident list) => *)
  | LetDum of (pident * 't)
    (* pident.pi_spec_name must be None *)
  | CaseDum of ('t * string * pident list)
    (* all pident.pi_spec_name must be None *)
  | OutputTerm of 't option

(* A execution path of the function. *)
type 't ps_branch = {
  psb_prop_name : string option;
  psb_branch : ('t ps_atom * string option) list;
                           (* a name used in proof generation *)
}

(* Proof scheme: representation of a fix function that look like the functional 
   inductive scheme generated by Coq. *)
type 't proof_scheme = {
  scheme_branches : 't ps_branch list;
}

(* Proof scheme pretty printer *)
val pp_proof_scheme : ('t -> string) -> 't proof_scheme -> string


