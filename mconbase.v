(* generated by Ott 0.23 from: mconbase.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.


Definition value_name := nat.
Lemma eq_value_name: forall (x y : value_name), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_value_name : ott_coq_equality.
Definition index := nat.

Inductive typexpr : Set := 
 | TE_unit : typexpr
 | TE_arrow (typexpr5:typexpr) (typexpr':typexpr)
 | TE_prod (typexpr5:typexpr) (typexpr':typexpr)
 | TE_concurrent (typexpr5:typexpr)
 | TE_sum (typexpr5:typexpr) (typexpr':typexpr).

Inductive expr : Set := 
 | E_ident (value_name5:value_name)
 | E_unit : expr
 | E_apply (expr5:expr) (expr':expr)
 | E_bind (expr5:expr) (expr':expr)
 | E_function (x:value_name) (t:typexpr) (e:expr)
 | E_fix (e:expr)
 | E_comp (e:expr)
 | E_live_expr (e:expr)
 | E_pair (e:expr) (e':expr)
 | E_proj1 (e:expr)
 | E_proj2 (e:expr)
 | E_fork (e:expr) (e':expr)
 | E_ret (e:expr)
 | E_taggingleft (e:expr)
 | E_taggingright (e:expr)
 | E_case (e:expr) (x1:value_name) (e1:expr) (x2:value_name) (e2:expr).

Inductive redlabel : Set := 
 | RL_tau : redlabel
 | RL_labelled (expr5:expr).

Inductive G : Set := 
 | G_em : G
 | G_vn (G5:G) (value_name5:value_name) (typexpr5:typexpr).

(** subrules *)
Fixpoint is_value_of_expr (e_5:expr) : Prop :=
  match e_5 with
  | (E_ident value_name5) => False
  | E_unit => (True)
  | (E_apply expr5 expr') => False
  | (E_bind expr5 expr') => False
  | (E_function x t e) => (True)
  | (E_fix e) => False
  | (E_comp e) => False
  | (E_live_expr e) => (True)
  | (E_pair e e') => ((is_value_of_expr e) /\ (is_value_of_expr e'))
  | (E_proj1 e) => False
  | (E_proj2 e) => False
  | (E_fork e e') => False
  | (E_ret e) => False
  | (E_taggingleft e) => ((is_value_of_expr e))
  | (E_taggingright e) => ((is_value_of_expr e))
  | (E_case e x1 e1 x2 e2) => False
end.

(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Implicit Arguments list_mem.


(** substitutions *)
Fixpoint subst_expr (e_5:expr) (x_5:value_name) (e__6:expr) {struct e__6} : expr :=
  match e__6 with
  | (E_ident value_name5) => (if eq_value_name value_name5 x_5 then e_5 else (E_ident value_name5))
  | E_unit => E_unit 
  | (E_apply expr5 expr') => E_apply (subst_expr e_5 x_5 expr5) (subst_expr e_5 x_5 expr')
  | (E_bind expr5 expr') => E_bind (subst_expr e_5 x_5 expr5) (subst_expr e_5 x_5 expr')
  | (E_function x t e) => E_function x t (if list_mem eq_value_name x_5 (cons x nil) then e else (subst_expr e_5 x_5 e))
  | (E_fix e) => E_fix (subst_expr e_5 x_5 e)
  | (E_comp e) => E_comp (subst_expr e_5 x_5 e)
  | (E_live_expr e) => E_live_expr (subst_expr e_5 x_5 e)
  | (E_pair e e') => E_pair (subst_expr e_5 x_5 e) (subst_expr e_5 x_5 e')
  | (E_proj1 e) => E_proj1 (subst_expr e_5 x_5 e)
  | (E_proj2 e) => E_proj2 (subst_expr e_5 x_5 e)
  | (E_fork e e') => E_fork (subst_expr e_5 x_5 e) (subst_expr e_5 x_5 e')
  | (E_ret e) => E_ret (subst_expr e_5 x_5 e)
  | (E_taggingleft e) => E_taggingleft (subst_expr e_5 x_5 e)
  | (E_taggingright e) => E_taggingright (subst_expr e_5 x_5 e)
  | (E_case e x1 e1 x2 e2) => E_case (subst_expr e_5 x_5 e) x1 (if list_mem eq_value_name x_5 (cons x1 nil) then e1 else (subst_expr e_5 x_5 e1)) x2 (if list_mem eq_value_name x_5 (cons x2 nil) then e2 else (subst_expr e_5 x_5 e2))
end.

Definition subst_redlabel (e5:expr) (x5:value_name) (rl5:redlabel) : redlabel :=
  match rl5 with
  | RL_tau => RL_tau 
  | (RL_labelled expr5) => RL_labelled (subst_expr e5 x5 expr5)
end.

(** library functions *)
Fixpoint list_minus A (eq:forall a b:A,{a=b}+{a<>b}) (l1:list A) (l2:list A) {struct l1} : list A :=
  match l1 with
  | nil => nil
  | cons h t => if (list_mem (A:=A) eq h l2) then list_minus A eq t l2 else cons h (list_minus A eq t l2)
end.
Implicit Arguments list_minus.


(** free variables *)
Fixpoint fv_expr (e_5:expr) : list value_name :=
  match e_5 with
  | (E_ident value_name5) => (cons value_name5 nil)
  | E_unit => nil
  | (E_apply expr5 expr') => (app (fv_expr expr5) (fv_expr expr'))
  | (E_bind expr5 expr') => (app (fv_expr expr5) (fv_expr expr'))
  | (E_function x t e) => ((list_minus eq_value_name (fv_expr e) (cons x nil)))
  | (E_fix e) => ((fv_expr e))
  | (E_comp e) => ((fv_expr e))
  | (E_live_expr e) => ((fv_expr e))
  | (E_pair e e') => (app (fv_expr e) (fv_expr e'))
  | (E_proj1 e) => ((fv_expr e))
  | (E_proj2 e) => ((fv_expr e))
  | (E_fork e e') => (app (fv_expr e) (fv_expr e'))
  | (E_ret e) => ((fv_expr e))
  | (E_taggingleft e) => ((fv_expr e))
  | (E_taggingright e) => ((fv_expr e))
  | (E_case e x1 e1 x2 e2) => (app (fv_expr e) (app (list_minus eq_value_name (fv_expr e1) (cons x1 nil)) (list_minus eq_value_name (fv_expr e2) (cons x2 nil))))
end.

Definition fv_redlabel (rl5:redlabel) : list value_name :=
  match rl5 with
  | RL_tau => nil
  | (RL_labelled expr5) => ((fv_expr expr5))
end.


Inductive selectopt : Set := 
 | SO_First : selectopt
 | SO_Second : selectopt.
CoInductive select_h : Set := 
| S_Seq (o:selectopt) (s:select_h). 

Definition select : Set := select_h.
(** definitions *)

(* defns Jtype *)
Inductive VTSin : value_name -> typexpr -> G -> Prop :=    (* defn VTSin *)
 | VTSin_vn1 : forall (value_name5:value_name) (typexpr5:typexpr) (G5:G),
     VTSin value_name5 typexpr5 (G_vn G5 value_name5 typexpr5)
 | VTSin_vn2 : forall (value_name5:value_name) (typexpr5:typexpr) (G5:G) (value_name':value_name) (typexpr':typexpr),
     VTSin value_name5 typexpr5 G5 ->
      ~(  value_name5 = value_name'  )  ->
     VTSin value_name5 typexpr5 (G_vn G5 value_name' typexpr')
with Get : G -> expr -> typexpr -> Prop :=    (* defn Get *)
 | Get_ret : forall (G5:G) (e:expr) (t:typexpr),
     Get G5 e t ->
     Get G5 (E_ret e) (TE_concurrent t)
 | Get_fork : forall (G5:G) (e e':expr) (t1 t2:typexpr),
     Get G5 e  (TE_concurrent t1)  ->
     Get G5 e'  (TE_concurrent t2)  ->
     Get G5 (E_fork e e')  (TE_concurrent  (TE_sum  (TE_prod t1  (TE_concurrent t2) )   (TE_prod  (TE_concurrent t1)  t2) ) ) 
 | Get_unit : forall (G5:G),
     Get G5 E_unit TE_unit
 | Get_proj1 : forall (G5:G) (e:expr) (t1 t2:typexpr),
     Get G5 e  (TE_prod t1 t2)  ->
     Get G5 (E_proj1 e) (TE_arrow  (TE_prod t1 t2)  t1)
 | Get_proj2 : forall (G5:G) (e:expr) (t1 t2:typexpr),
     Get G5 e  (TE_prod t1 t2)  ->
     Get G5 (E_proj2 e) (TE_arrow  (TE_prod t1 t2)  t2)
 | Get_value_name : forall (G5:G) (x:value_name) (t:typexpr),
     VTSin x t G5 ->
     Get G5 (E_ident x) t
 | Get_apply : forall (G5:G) (e e':expr) (t2 t1:typexpr),
     Get G5 e (TE_arrow t1 t2) ->
     Get G5 e' t1 ->
     Get G5 (E_apply e e') t2
 | Get_lambda : forall (G5:G) (x1:value_name) (t1:typexpr) (e:expr) (t:typexpr),
     Get (G_vn G5 x1 t1) e t ->
     Get G5 (E_function x1 t1 e) (TE_arrow t1 t)
 | Get_live_exp : forall (G5:G) (e:expr) (t:typexpr),
     Get G5 e t ->
     Get G5 (E_live_expr e) (TE_concurrent t)
 | Get_comp : forall (G5:G) (e:expr) (t:typexpr),
     Get G5 e t ->
     Get G5  (E_comp e)  t
 | Get_fix : forall (G5:G) (e:expr) (t:typexpr),
     Get G5 e (TE_arrow t t) ->
     Get G5 (E_fix e) t
 | Get_bind : forall (G5:G) (e e':expr) (t' t:typexpr),
     Get G5 e (TE_concurrent t) ->
     Get G5 e' (TE_arrow t (TE_concurrent t')) ->
     Get G5 (E_bind e e') (TE_concurrent t')
 | Get_pair : forall (G5:G) (e e':expr) (t1 t2:typexpr),
     Get G5 e t1 ->
     Get G5 e' t2 ->
     Get G5 (E_pair e e')  (TE_prod t1 t2) 
 | Get_TInl : forall (G5:G) (e:expr) (t t':typexpr),
     Get G5 e t ->
     Get G5 (E_taggingleft e) (TE_sum t t')
 | Get_TInr : forall (G5:G) (e:expr) (t' t:typexpr),
     Get G5 e t ->
     Get G5 (E_taggingright e) (TE_sum t' t)
 | Get_TCase : forall (G5:G) (e:expr) (x:value_name) (e':expr) (x':value_name) (e'':expr) (t'' t t':typexpr),
     Get G5 e (TE_sum t t') ->
     Get (G_vn G5 x t) e' t'' ->
     Get (G_vn G5 x' t') e'' t'' ->
     Get G5 (E_case e x e' x' e'') t''.
(** definitions *)

(* defns Jop *)
Inductive JO_red : expr -> select -> redlabel -> expr -> Prop :=    (* defn red *)
 | JO_red_app : forall (x:value_name) (t:typexpr) (e:expr) (s:select) (v:expr),
     is_value_of_expr v ->
     JO_red (E_apply  (E_function x t e)  v) s RL_tau  (subst_expr  v   x   e ) 
 | JO_red_docomp : forall (e:expr) (s:select),
     JO_red (E_comp e) s (RL_labelled e) e
 | JO_red_forkeval1 : forall (e e':expr) (s:select) (rl:redlabel) (e'':expr),
     JO_red e s rl e'' ->
     JO_red (E_fork e e') s rl (E_fork e'' e')
 | JO_red_forkeval2 : forall (v e':expr) (s:select) (rl:redlabel) (e'':expr),
     is_value_of_expr v ->
     JO_red e' s rl e'' ->
     JO_red (E_fork v e') s rl (E_fork v e'')
 | JO_red_forkmove1 : forall (e e':expr) (s:select) (rl:redlabel) (e'':expr),
     JO_red e s rl e'' ->
      ~(is_value_of_expr( e' ))  ->
     JO_red (E_fork  (E_live_expr e)   (E_live_expr e') ) (S_Seq SO_First s) rl (E_fork  (E_live_expr e'')   (E_live_expr e') )
 | JO_red_forkmove2 : forall (e e':expr) (s:select) (rl:redlabel) (e'':expr),
     JO_red e' s rl e'' ->
      ~(is_value_of_expr( e ))  ->
     JO_red (E_fork  (E_live_expr e)   (E_live_expr e') ) (S_Seq SO_Second s) rl (E_fork  (E_live_expr e)   (E_live_expr e'') )
 | JO_red_forkdeath1 : forall (v e:expr) (s:select),
     is_value_of_expr v ->
     JO_red (E_fork  (E_live_expr v)   (E_live_expr e) ) s RL_tau (E_live_expr  (E_taggingleft   (E_pair v  (E_live_expr e) )  ) )
 | JO_red_forkdeath2 : forall (e v':expr) (s:select),
     is_value_of_expr v' ->
     JO_red (E_fork  (E_live_expr e)   (E_live_expr v') ) s RL_tau (E_live_expr  (E_taggingright  (E_pair  (E_live_expr e)  v') ) )
 | JO_red_ret : forall (v:expr) (s:select),
     is_value_of_expr v ->
     JO_red (E_ret v) s RL_tau  (E_live_expr v) 
 | JO_red_evalret : forall (e:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_ret e) s rl (E_ret e')
 | JO_red_evalbind : forall (e e'':expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_bind e e'') s rl (E_bind e' e'')
 | JO_red_movebind : forall (e e'':expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_bind  (E_live_expr e)  e'') s rl (E_bind  (E_live_expr e')  e'')
 | JO_red_dobind : forall (v e:expr) (s:select),
     is_value_of_expr v ->
     JO_red (E_bind  (E_live_expr v)  e) s RL_tau (E_apply e v)
 | JO_red_context_app2 : forall (v e':expr) (s:select) (rl:redlabel) (e'':expr),
     is_value_of_expr v ->
     JO_red e' s rl e'' ->
     JO_red (E_apply v e') s rl (E_apply v e'')
 | JO_red_context_app1 : forall (e e':expr) (s:select) (rl:redlabel) (e'':expr),
     JO_red e s rl e'' ->
     JO_red (E_apply e e') s rl (E_apply e'' e')
 | JO_red_fix_move : forall (e:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red  (E_fix e)  s rl  (E_fix e') 
 | JO_red_fix_app : forall (x:value_name) (t:typexpr) (e:expr) (s:select),
     JO_red  (E_fix  (E_function x t e) )  s RL_tau  (subst_expr (E_fix  (E_function  x   t   e ) )  x   e ) 
 | JO_red_pair_1 : forall (e e'':expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_pair e e'') s rl (E_pair e' e'')
 | JO_red_pair_2 : forall (v e:expr) (s:select) (rl:redlabel) (e':expr),
     is_value_of_expr v ->
     JO_red e s rl e' ->
     JO_red (E_pair v e) s rl (E_pair v e')
 | JO_red_proj1 : forall (v v':expr) (s:select),
     is_value_of_expr v ->
     is_value_of_expr v' ->
     JO_red (E_proj1 (E_pair v v')) s RL_tau v
 | JO_red_proj2 : forall (v v':expr) (s:select),
     is_value_of_expr v ->
     is_value_of_expr v' ->
     JO_red (E_proj2 (E_pair v v')) s RL_tau v'
 | JO_red_proj1_eval : forall (e:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_proj1 e) s rl (E_proj1 e')
 | JO_red_proj2_eval : forall (e:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_proj2 e) s rl (E_proj2 e')
 | JO_red_evalinl : forall (e:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_taggingleft e) s rl (E_taggingleft e')
 | JO_red_evalinr : forall (e:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_taggingright e) s rl (E_taggingright e')
 | JO_red_evalcaseinl : forall (x1:value_name) (e1:expr) (x2:value_name) (e2:expr) (s:select) (v:expr),
     is_value_of_expr v ->
     JO_red (E_case  (E_taggingleft v)  x1 e1 x2 e2) s RL_tau  (subst_expr  v   x1   e1 ) 
 | JO_red_evalcaseinr : forall (x1:value_name) (e:expr) (x2:value_name) (e2:expr) (s:select) (v:expr),
     is_value_of_expr v ->
     JO_red (E_case  (E_taggingright v)  x1 e x2 e2) s RL_tau  (subst_expr  v   x2   e2 ) 
 | JO_red_evalcase : forall (e:expr) (x1:value_name) (e1:expr) (x2:value_name) (e2:expr) (s:select) (rl:redlabel) (e':expr),
     JO_red e s rl e' ->
     JO_red (E_case e x1 e1 x2 e2) s rl (E_case e' x1 e1 x2 e2).


